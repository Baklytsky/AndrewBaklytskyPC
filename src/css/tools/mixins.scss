/*================ Media Query Mixin ================*/
@mixin media-query($media-query) {
  $breakpoint-found: false;

  @each $breakpoint in $breakpoints {
    $name: nth($breakpoint, 1);
    $declaration: nth($breakpoint, 2);

    @if $media-query == $name and $declaration {
      $breakpoint-found: true;

      @media only screen and #{$declaration} {
        @content;
      }
    }
  }

  @if $breakpoint-found == false {
    @warn 'Breakpoint "#{$media-query}" does not exist';
  }
}

@mixin pseudo-overlay {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--overlay);
  opacity: var(--overlay-opacity);
}

@mixin visually-hidden {
  position: absolute;
  overflow: hidden;
  clip: rect(0 0 0 0);
  height: 1px;
  width: 1px;
  margin: -1px;
  padding: 0;
  border: 0;
}

@mixin visually-shown($position: inherit) {
  // sass-lint:disable no-important
  position: $position !important;
  overflow: auto;
  clip: auto;
  width: auto;
  height: auto;
  margin: 0;
}

.fallback-text {
  @extend .visually-hidden;
}

@mixin clearfix() {
  &:after {
    content: '';
    display: table;
    clear: both;
  }
}

/*============================================================================
  Prefixer mixin for generating vendor prefixes:
    - Based on https://github.com/thoughtbot/bourbon/blob/master/app/assets/stylesheets/addons/_prefixer.scss
    - Usage:

      // Input:
      .element {
        @include prefixer(transform, scale(1), ms webkit spec);
      }

      // Output:
      .element {
        -ms-transform: scale(1);
        -webkit-transform: scale(1);
        transform: scale(1);
      }
==============================================================================*/

@mixin prefixer($property, $value, $prefixes) {
  @each $prefix in $prefixes {
    @if $prefix == webkit {
      -webkit-#{$property}: $value;
    } @else if $prefix == moz {
      -moz-#{$property}: $value;
    } @else if $prefix == ms {
      -ms-#{$property}: $value;
    } @else if $prefix == o {
      -o-#{$property}: $value;
    } @else if $prefix == spec {
      #{$property}: $value;
    } @else {
      @warn 'Unrecognized prefix: #{$prefix}';
    }
  }
}

@mixin user-select($value: none) {
  @include prefixer(user-select, $value, webkit moz ms spec);
}

@mixin backface($visibility: hidden) {
  @include prefixer(backface-visibility, $visibility, webkit spec);
}

/*============================================================================
  Layer promotion mixin for creating smoother animations with higher FPS.
==============================================================================*/
@mixin promote-layer($properties: transform) {
  /*   -webkit-transform: translateZ(0); // translateZ hack */
  will-change: $properties; // spec
}

/*============================================================================
  Text truncate
==============================================================================*/
@mixin truncate($lines: 4) {
  display: -webkit-box;
  overflow: hidden;
  text-overflow: ellipsis;
  -webkit-line-clamp: $lines;
  -webkit-box-orient: vertical;
}

/*================ Chevron ================*/
@mixin chevron($dimensions, $width, $bgColor, $rotation, $direction) {
  &:before,
  &:after {
    content: '';
    position: absolute;
    width: $dimensions;
    height: $width;
    border-radius: calc(#{$width} / 2);
    background-color: $bgColor;

    @if $direction == 'left' {
      left: calc(50% - #{$dimensions});
    } @else {
      right: calc(50% - #{$dimensions});
    }
  }

  &:before {
    top: calc(50% - #{$width} / 2);
    @if $direction == 'left' {
      transform: rotate($rotation) translate(50%, -50%);
    } @else {
      transform: rotate(calc(180deg - #{$rotation})) translate(50%, 50%);
    }
  }

  &:after {
    bottom: calc(50% - #{$width} / 2);
    @if $direction == 'left' {
      transform: rotate(-$rotation) translate(50%, 50%);
    } @else {
      transform: rotate(calc(180deg + #{$rotation})) translate(50%, -50%);
    }
  }
}

/*================ Ordered items delay ================*/
/*
  Accepts:
    - $limit:     {Number} Number of elements that would be animated in order. [Default: 30]
    - $initial:   {Number in milliseconds} The first element initial delay, i.e. the one that has `data-aos-order="1"` attribute. [Default: 300]
    - $between:   {Number in milliseconds} Maximum amount of delay between elements from which to start to decrease and narrow down the range. The value is responsible for spacing out each ordered element delay from the next one. Setting "500" means the second element's delay will start approximately 500ms (at most) after the first element. [Default: 120]
    - $growth:    {Number in milliseconds} The rate at which each next delay is increased. Set a value between "0" and "100". Value of "0" creates a linear growth, whereas "100" leads to exponential growth. [Default: 100]

  Usage:
    @include ordered-items-delay(30, 300, 120, 100);
*/

@mixin ordered-items-delay($limit: 30, $initial: 300, $between: 120, $growth: 100) {
  $prevDelay: 0;
  $initial: $initial * 1ms;
  $growth: $growth * 1ms;

  @for $i from 1 through $limit {
    $base: $i * $between;
    $fraction: calc($i / ($limit * 2));
    $factor: calc($base / 100 * $fraction);
    $delay: $base + $initial - $factor * $growth;
    $diff: $factor * 100 - $delay;

    [data-aos-order="#{$i}"] {
      @if $diff < 0 {
        $prevBase: ($i - 1) * $between;
        $prevFraction: calc(($i - 1) / ($limit * 2));
        $prevFactor: calc($prevBase / 100 * $prevFraction);
        $prevDelay: $prevBase + $initial - $prevFactor * $growth;

        @if $delay > $prevDelay {
          animation-delay: $prevDelay;
        } @else {
          animation-delay: $delay;
        }
      } @else {
        animation-delay: $prevDelay;
      }
    }
  }
}

@mixin hide-scrollbar {
  scrollbar-width: none;
  -ms-overflow-style: none; /* for Internet Explorer, Edge */
  &::-webkit-scrollbar {
    display: none; /* for Chrome, Safari, and Opera */
  }
}

@mixin scrollbar-on-hover {
  // Here is the magic that hides up the scrollbar
  --double-scrollbar-width: calc(1.8 * var(--scrollbar-width));
  @include media-query($medium-down) {
    --double-scrollbar-width: 0;
  }

  mask-image: linear-gradient(to top, transparent, black),
    linear-gradient(to left, transparent var(--double-scrollbar-width), black var(--double-scrollbar-width));
  mask-size: 100% 20000px;
  mask-position: left bottom;
  -webkit-mask-image: linear-gradient(to top, transparent, black),
    linear-gradient(to left, transparent var(--double-scrollbar-width), black var(--double-scrollbar-width));
  -webkit-mask-size: 100% 20000px;
  -webkit-mask-position: left bottom;
  transition: mask-position 0.3s, -webkit-mask-position 0.3s;

  // Show up the scrollbar on hover
  &:hover {
    -webkit-mask-position: left top;
  }
}

@mixin sidebar-close {
  position: absolute;
  top: 8px;
  right: 0;
  width: 54px;
  height: 54px;
  padding: 18px;
  color: inherit;
  text-decoration: none;

  svg {
    display: block;
    width: 100%;
    height: 100%;
    transition: transform 0.3s ease;
    pointer-events: none;
  }

  &:hover svg { transform: rotate(90deg); }
}

@mixin lightbox-close {
  display: block;
  position: absolute;
  top: 8px;
  right: 8px;
  width: 44px;
  height: 44px;
  padding: 12px;
  z-index: 4;
  border: 0;
  background-color: var(--bg);
  color: var(--text);
  text-align: center;

  &:hover .icon-close { transform: rotate(90deg); }
}

/*================ Miscellaneous ================*/

@mixin box_shadow($level) {
  @if $level == 1 {
    box-shadow: 0 1px 3px rgb(0 0 0 / 4%), 0 1px 2px rgb(0 0 0 / 6%);
  } @else if $level == 2 {
    box-shadow: 0 2px 6px rgb(0 0 0 / 6%), 0 1px 3px rgb(0 0 0 / 6%);
  } @else if $level == 3 {
    box-shadow: 0 4px 14px rgb(0 0 0 / 8%), 0 3px 6px rgb(0 0 0 / 6%);
  } @else if $level == 4 {
    box-shadow: 0 4px 20px rgb(0 0 0 / 10%), 0 1px 3px rgb(0 0 0 / 7%);
  }
}

@mixin animated-border-hover($hover: 1) {
  position: relative;
  display: inline-block;
  text-decoration: none !important;

  &:before,
  &:after {
    content: '';
    position: absolute;
    left: 0;
    bottom: -0.1rem;
    width: 100%;
    height: var(--BORDER-WIDTH);
    display: block;
    background: var(--btn-text, var(--text));
    transition: none;
    pointer-events: none;
  }

  &:before {
    transform: scaleX(0);
    transform-origin: left;
  }

  &:after {
    transform-origin: right;
  }

  @if $hover == 1 {
    .no-touch & {
      &:hover {
        background: transparent;
        border: 0;
      }

      &:hover:before,
      &:hover:after {
        transition: transform 1.1s cubic-bezier(0.19, 1, 0.22, 1);
        transform: scaleX(0);
      }

      &:hover:before {
        transform: scaleX(1);
        transition-delay: 0.25s;
      }
    }
  }
}
